




1. 6Naming Guidelines

### Use US-English  (AV1701) ![](images/?.png)

All type members, parameters and variables should be named using words from the American English language.

- Choose easily readable, preferably grammatically correct names. For example, HorizontalAlignment is more readable than AlignmentHorizontal.
- Favor readability over brevity. The property name CanScrollHorizontally is better than ScrollableX (an obscure reference to the X-axis).
- Avoid using names that conflict with keywords of widely used programming languages.

**Exception** In most projects, you will use words and phrases from your domain and names specific to your company. Visual Studio's Static Code Analysis will perform a spelling check on all code, so you may need to add those terms to a [Custom Code Analysis Dictionary](http://blogs.msdn.com/fxcop/archive/2007/08/20/new-for-visual-studio-2008-custom-dictionaries.aspx).

### Use proper casing for language elements 
 (AV1702) ![](images/?.png) **Language element** | **Casing** | ** Example** |
| --- | --- | --- |
| Class, Struct | Pascal | AppDomain |
| Interface | Pascal | IBusinessService |
| Enumeration type | Pascal | ErrorLevel |
| Enumeration values | Pascal | FatalError |
| Event | Pascal | Click |
| Private field | Camel | listItem |
| Protected field | Pascal | MainPanel |
| Const field | Pascal | MaximumItems |
| Const variable | Camel | maximumItems |
| Read-only static field | Pascal | RedValue |
| Variable | Camel | listOfValues |
| Method | Pascal | ToString |
| Namespace | Pascal | System.Drawing |
| Parameter | Camel | typeName |
| Type Parameter | Pascal | TView |
| Property | Pascal | BackColor |

### Don't include numbers in variables, parameters and type members  (AV1704) ![](images/?.png)

In most cases they are a lazy excuse for not defining a clear and intention-revealing name.

### Don't prefix fields  (AV1705) ![](images/?.png)

For example, don't use g\_ or s\_ to distinguish static versus non-static fields. In general, a method in which it is difficult to distinguish local variables from member fields is too big. Examples of incorrect identifier names are: \_currentUser, mUserName, m\_loginTime.

### Don't use abbreviations  (AV1706) ![](images/?.png)

For example, use OnButtonClick rather than OnBtnClick. Avoid single character variable names, such as i or q. Use index or query instead.

**Exceptions** Use well-known abbreviations that are widely accepted or well-known within the domain you work. For instance, use UIinstead of UserInterface.

### Name a member, parameter or variable according its meaning and not its type  (AV1707) ![](images/?.png)

- Use functional names. For example, GetLength is a better name than GetInt.
- Don't use terms like Enum, Class or Struct in a name.
- Identifiers that refer to a collection type should have a plural name.

### Name types using nouns, noun phrases or adjective phrases  (AV1708) ![](images/?.png)

Bad examples include SearchExamination (a page for searching for examinations), Common (does not end with a noun, and does not explain its purpose) and SiteSecurity (although the name is technically okay, it does not say anything about its purpose). Good examples include BusinessBinder, SmartTextBox, or EditableSingleCustomer.

Don't include terms like Utility or Helper in classes. Classes with a name like that are usually static classes and are introduced without considering the object-oriented principles (see also AV1008).

### Name generic type parameters with descriptive names  (AV1709) ![](images/?.png)

- Always prefix descriptive type parameter names with the letter T.
- Always use a descriptive names unless a single-letter name is completely self-explanatory and a longer name would not add value. Use the single letter T as the type parameter in that case.
- Consider indicating constraints placed on a type parameter in the name of parameter. For example, a parameter constrained to ISession may be called TSession.

### Don't repeat the name of a class or enumeration in its members  (AV1710) ![](images/?.png)

class Employee

{

// Wrong!

static GetEmployee() {}

DeleteEmployee() {}

// Right

 static Get() {...}

Delete() {...}

// Also correct.

AddNewJob() {...}

RegisterForMeeting() {...}

}

### Name members similarly to members of related .NET Framework classes  (AV1711) ![](images/?.png)

.NET developers are already accustomed to the naming patterns the framework uses, so following this same pattern helps them find their way in your classes as well. For instance, if you define a class that behaves like a collection, provide members like Add, Remove and Count instead of AddItem, Delete or NumberOfItems.

### Avoid short names or names that can be mistaken with other names  (AV1712) ![](images/?.png)

Although technically correct, the following statement can be quite confusing.

bool b001 = (lo == l0) ? (I1 == 11) : (lOl != 101);

### Properly name properties  (AV1715) ![](images/?.png)

- Do name properties with nouns, noun phrases, or occasionally adjective phrases. 
- Do name Boolean properties with an affirmative phrase. E.g. CanSeek instead of CantSeek.
- Consider prefixing Boolean properties with Is, Has, Can, Allows, or Supports.
- Consider giving a property the same name as its type. When you have a property that is strongly typed to an enumeration, the name of the property can be the same as the name of the enumeration. For example, if you have an enumeration named CacheLevel, a property that returns one of its values can also be named CacheLevel.

### Name methods using verb-object pair  (AV1720) ![](images/?.png)

Name methods using a verb-object pair such as ShowDialog. A good name should give a hint on the _what_ of a member, and if possible, the _why_. Also, don't include And in the name of the method. It implies that the method is doing more than one thing, which violates the single responsibility principle explained in AV1115.

### Name namespaces using names, layers, verbs and features  (AV1725) ![](images/?.png)

For instance, the following namespaces are good examples of that guideline.

AvivaSolutions.Commerce.Web

NHibernate.Extensibility

Microsoft.ServiceModel.WebApi

Microsoft.VisualStudio.Debugging

FluentAssertion.Primitives

CaliburnMicro.Extensions

**Note** Never allow namespaces to contain the name of a type, but a noun in its plural form, e.g. Collections, is usually okay.

### Use a verb or verb phrase to name an event  (AV1735) ![](images/?.png)

Name events with a verb or a verb phrase. For example: Click, Deleted, Closing, Minimizing, and Arriving. For example, the declaration of the Search event may look like this:

public event EventHandler Search;

### Use -ing and -ed to express pre-events and post-events  (AV1737) ![](images/?.png)

For example, a close event that is raised before a window is closed would be called Closing and one that is raised after the window is closed would be called Closed. Don't use Before or After prefixes or suffixes to indicate pre and post events.

Suppose you want to define events related to the deletion process of an object. Avoid defining the Deleting and Deleted events as BeginDelete and EndDelete. Define those events as follows:

- Deleting: Occurs just before the object is getting deleted
- Delete: Occurs when the object needs to be deleted by the event handler.
- Deleted: Occurs when the object is already deleted.

### Prefix an event handler with On (AV1738) ![](images/?.png)

It is good practice to prefix the method that handles an event with On. For example, a method that handles the Closing event could be named OnClosing.

### Use an underscore for irrelevant lambda parameters  (AV1739) ![](images/?.png)

If you use a lambda statement, for instance, to subscribe to an event, and the actual parameters of the event are irrelevant, use the following convention to make that more explicit.

button.Click += (\_, \_\_) => HandleClick();

### Group extension methods in a class suffixed with Extensions (AV1745) ![](images/?.png)

If the name of an extension method conflicts with another member or extension method, you must prefix the call with the class name. Having them in a dedicated class with the Extensions suffix improves readability.

### Postfix asynchronous methods with Async of TaskAsync  (AV1755) ![](images/?.png)

The general convention for methods that return Task or Task is to post-fix them with Async, but if such a method already exist, use TaskAsync instead.



1. 7Performance Guidelines

### Consider using Any() to determine whether an IEnumerable is empty  (AV1800) ![](images/?.png)

When a method or other member returns an IEnumerable or other collection class that does not expose a Count property, use the Any() extension method rather than Count() to determine whether the collection contains items. If you do use Count(), you risk that iterating over the entire collection might have a significant impact (such as when it really is an IQueryable to a persistent store).

**Note** If you return an IEnumerable to prevent editing from outside the owner as explained in AV1130 and you're developing in .NET 4.5 or higher, consider the new read-only classes.

### AV1820    Only use async for low-intensive long-running activities

The usage of async won't automagically run something on a worker thread like Task.Run does. It just adds the necessary logic to allow releasing the current thread and marshal the result back on that same thread if a long-running asynchronies operation has completed. In other words, use async only for I/O bound operations.

### AV1825    Prefer Task.Run for CPU intensive activities

If you do need to execute a CPU bound operation, use Task.Run to offload the work to a thread from the Thread Pool. Just don't forget that you have to marshal the result back to your main thread manually.

### AV1830    Beware of mixing up await/async with Task.Wait

await will not block the current thread but simply instruct to compiler to generate a state-machine. However, Task.Wait will block the thread and may even cause dead-locks (see AV1835).

### AV1835    Beware of async/await deadlocks in single-threaded environments

Consider the following asynchronous method:

private async Task GetDataAsync()

{

var result = await MyWebService.GetDataAsync();

return result.ToString();

}

Now when an ASP.NET MVC controller action does this:

public ActionResult ActionAsync()

{

var data = GetDataAsync().Result;



return View(data);  
}

You'll end up with a deadlock. Why? Because the Result property getter will block until the async operation has completed, but since an async method will automatically marshal the result back to the original thread and ASP.NET uses a single-threaded synchronization context, they'll be waiting on each other. A similar problem can also happen on WPF, Silverlight or a Windows Store C#/XAML app. Read more about this [here](http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115163.aspx).

1. 8Framework Guidelines

### Use C# type aliases instead of the types from the System namespace  (AV2201) ![](images/?.png)

For instance, use object instead of Object, string instead of String, and int instead of Int32. These aliases have been introduced to make the primitive types a first class citizen of the C# language so use them accordingly,

**Exception** When referring to static members of those types, it is custom to use the full CLS name, e.g. Int32.Parse() instead of int.Parse().

### Properly name properties, variables or fields referring to localized resources  (AV2205) ![](images/?.png)

The guidelines in this topic apply to localizable resources such as error messages and menu text.

- Use Pascal casing in resource keys.
- Provide descriptive rather than short identifiers. Keep them concise where possible, but don't sacrifice readability.
- Use only alphanumeric characters in naming resources.

### Don't hardcode strings that change based on the deployment  (AV2207) ![](images/?.png)

Examples include connection strings, server addresses, etc. Use Resources, the ConnectionStrings property of the ConfigurationManager class, or the Settings class generated by Visual Studio. Maintain the actual values into the app.config or web.config (and most definitely not in a custom configuration store).

### Build with the highest warning level  (AV2210) ![](images/?.png)

Configure the development environment to use **Warning Level 4** for the C# compiler, and enable the option **Treat warnings as errors** . This allows the compiler to enforce the highest possible code quality.

### Properly fill the attributes of the AssemblyInfo.cs file  (AV2215) ![](images/?.png)

Ensure that the attributes for the company name, description, copyright statement, version, etc. are filled. One way to ensure that version and other fields that are common to all assemblies have the same values, is to move the corresponding attributes out of the AssemblyInfo.cs into a SolutionInfo.cs file that is shared by all projects within the solution. 

### Avoid LINQ for simple expressions  (AV2220) ![](images/?.png)

Rather than

var query = from item in items where item.Length > 0;

prefer using the extension methods from the System.Linq namespace.

var query = items.Where(i => i.Length > 0);

Since LINQ queries should be written out over multiple lines for readability, the second example is a bit more readable.

### Use Lambda expressions instead of delegates  (AV2221) ![](images/?.png)

Lambda expressions provide a much more elegant alternative for anonymous delegates. So instead of

Customer c = Array.Find(customers, delegate(Customer c)

{

return c.Name == "Tom";

});

use a Lambda expression:

Customer c = Array.Find(customers, c => c.Name == "Tom");

Or even better

var customer = customers.Where(c => c.Name == "Tom");

### Only use the dynamic keyword when talking to a dynamic object  (AV2230) ![](images/?.png)

The dynamic keyword has been introduced for working with dynamic languages. Using it introduces a serious performance bottleneck because the compiler has to generate some complex Reflection code.

Use it only for calling methods or members of a dynamically created instance (using the Activator) class as an alternative to Type.GetProperty() and Type.GetMethod(), or for working with COM Interop types.

### AV2235    Favor async/await over the Task

Using the new C# 5.0 keywords results in code that can still be read sequentially and also improves maintainability a lot, even if you need to chain multiple asynchronous operations. For example, rather than defining your method like this:

public Task GetDataAsync()

{

  return MyWebService.FetchDataAsync()

    .ContinueWith(t => new Data (t.Result));

}

define it like this:

public async Task GetDataAsync()

{

  var result = await MyWebService.FetchDataAsync();

  return new Data (result);

}

1. 9Documentation Guidelines

### Write comments and documentation in US English  (AV2301) ![](images/?.png)

### Document all public, protected and internal types and members  (AV2305) ![](images/?.png)

Documenting your code allows Visual Studio to pop-up the documentation when your class is used somewhere else. Furthermore, by properly documenting your classes, tools can generate professionally looking class documentation.

### Write XML documentation with another developer in mind  (AV2306) ![](images/?.png)

Write the documentation of your type with another developer in mind. Assume he or she will not have access to the source code and try to explain how to get the most out of the functionality of your type.

### Write MSDN-style documentation  (AV2307) ![](images/?.png)

Following the MSDN on-line help style and word choice helps the developer to find its way through your documentation more easily.

**Tip** The tool [GhostDoc](http://submain.com/products/ghostdoc.aspx)can generate a starting point for documenting code with a shortcut key.

### Avoid inline comments  (AV2310) ![](images/?.png)

If you feel the need to explain a block of code using a comment, consider replacing that block with a method having a clear name.

### Only write comments to explain complex algorithms or decisions  (AV2316) ![](images/?.png)

Try to focus comments on the _why_ and _what_ of a code block and not the _how_. Avoid explaining the statements in words, but instead help the reader understand why you chose a certain solution or algorithm and what you are trying to achieve. If applicable, also mention that you chose an alternative solution because you ran into a problem with the obvious solution.

### Don't use comments for tracking work to be done later  (AV2318) ![](images/?.png)

Annotating a block of code or some work to be done using a TODO or similar comment may seem a reasonable way of tracking work-to-be-done. But in reality, nobody really searches for comments like that. Use a work item tracking system such as Team Foundation Server to keep track of left overs.

1. 10Layout Guidelines

### Use a common layout  (AV2400) ![](images/?.png)

- Keep the length of each line under 130 characters.
- Use an indentation of 4 whitespaces, and don't use tabs
- Keep one whitespace between keywords like if and the expression, but don't add whitespaces after ( and before ) such as: if (condition == null).
- Add a whitespace around operators, like +, -, ==, etc.
- Always succeed the keywords if, else, do, while, for and foreach, with opening and closing parentheses, even though the language does not require it. 
- Always put opening and closing parentheses on a new line.
- Don't indent object Initializers and initialize each property on a new line, so use a format like this: var dto = new ConsumerDto(){  Id = 123,  Name = "Microsoft",  PartnerShip = PartnerShip.Gold,}
- Don't indent lambda statements and use a format like this:methodThatTakesAnAction.Do(x =>{ // do something like this }
- Put the entire LINQ statement on one line, or start each keyword at the same indentation, like this:var query = from product in products where product.Price > 10 select product;orvar query =  from product in products  where product.Price > 10  select product;
- Start the LINQ statement with all the from expressions and don't interweave them with where restrictions.
- Add braces around every comparison condition, but don't add braces around a singular condition. For exampleif (!string.IsNullOrEmpty(str) && (str != "new"))
- Add an empty line between multi-line statements, between members, after the closing parentheses, between unrelated code blocks, around the #region keyword, and between the using statements of different companies.

### Order and group namespaces according the company  (AV2402) ![](images/?.png)

// Microsoft namespaces are first

using System;

using System.Collections;

using System.XML;

// Then any other namespaces in alphabetic order

using AvivaSolutions.Business;

using AvivaSolutions.Standard;

using Telerik.WebControls;

using Telerik.Ajax;

### Place members in a well-defined order  (AV2406) ![](images/?.png)

Maintaining a common order allows other team members to find their way in your code more easily. In general, a source file should be readable from top to bottom, as if you are reading a book. This prevents readers from having to browse up and down through the code file.

1. Private fields and constants (in a region)
2. Public constants
3. Public read-only static fields
4. Factory Methods
5. Constructors and the Finalizer
6. Events 
7. Public Properties
8. Other methods and private properties in calling order

### Be reluctant with #regions  (AV2407) ![](images/?.png)

Regions can be helpful, but can also hide the main purpose of a class. Therefore, use #regions only for:

- Private fields and constants (preferably in a Private Definitions region).
- Nested classes
- Interface implementations (only if the interface is not the main purpose of that class)

1. 11Important Resources
  1. 1 [The](http://www.csharpcodingguidelines.com) companion website

This document is part of an effort to increase the consciousness with which C# developers do their daily job on a professional level. Therefor I've started a dedicated CodePlex site that can be easily found using the URL [www.csharpcodingguidelines.com](http://www.csharpcodingguidelines.com).

In addition to the most up to date version of this document, you'll find:

- A companion quick-reference sheet
- Visual Studio 2010/2012 Rule Sets for different types of systems.

[ReSharper](http://www.jetbrains.com/resharper/download/) layout configurations matching the rules in chapter 10.

- A place to have discussions on C# coding quality.

1. 
  1. 2Useful links

In addition to the many links provided throughout this document, I'd like to recommend the following books, articles and sites for everyone interests in software quality,

[Code Complete: A Practical Handbook of Software Construction](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670) (Steve McConnel)  
One of the best books I've ever read. It deals with all aspects of software development, and even though the book was originally written in 2004, but you'll be surprised when you see how accurate it still is. I wrote a [review](http://www.dennisdoomen.net/2009/07/book-review-code-complete-2nd-edition.htmlhttp:/www.dennisdoomen.net/2009/07/book-review-code-complete-2nd-edition.html) in 2009 if you want to get a sense of its contents.

[The Art of Agile Development](http://www.amazon.com/Art-Agile-Development-James-Shore/dp/0596527675) (James Shore)  
Another great all-encompassing trip through the many practices preached by processes like Scrum and Extreme Programming. If you're looking for a quick introduction with a pragmatic touch, make sure you read James' book.

[Applying Domain Driven-Design and Patterns: With Examples in C# and .NET](http://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202) (Jimmy Nilsson)  
The book that started my interest for both Domain Driven Design and Test Driven Development. It's one of those books that I wished I had read a few years earlier. It would have saved me from many mistakes..

[Jeremy D. Miller's Blog](http://codebetter.com/blogs/jeremy.miller/)  
Although he is not that active anymore, in the last couple of years he has written some excellent blog posts on Test Driven Development, Design Patterns and design principles. I've learned a lot from his real-life and practical insights.

[LINQ Framework Design Guidelines](http://blogs.msdn.com/b/mirceat/archive/2008/03/13/linq-framework-design-guidelines.aspx)  
A set of rules and recommendations that you should adhere to when creating your own implementations of IQueryable.

[Best Practices for c# async/await](http://code.jonwagner.com/2012/09/06/best-practices-for-c-asyncawait/)  
The rationale and source of several of the new guidelines in this documented, written by [Jon Wagner](https://twitter.com/jonwagnerdotcom).
