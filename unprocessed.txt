







1. 7Performance Guidelines

### Consider using Any() to determine whether an IEnumerable is empty  (AV1800) ![](images/?.png)

When a method or other member returns an IEnumerable or other collection class that does not expose a Count property, use the Any() extension method rather than Count() to determine whether the collection contains items. If you do use Count(), you risk that iterating over the entire collection might have a significant impact (such as when it really is an IQueryable to a persistent store).

**Note** If you return an IEnumerable to prevent editing from outside the owner as explained in AV1130 and you're developing in .NET 4.5 or higher, consider the new read-only classes.

### AV1820    Only use async for low-intensive long-running activities

The usage of async won't automagically run something on a worker thread like Task.Run does. It just adds the necessary logic to allow releasing the current thread and marshal the result back on that same thread if a long-running asynchronies operation has completed. In other words, use async only for I/O bound operations.

### AV1825    Prefer Task.Run for CPU intensive activities

If you do need to execute a CPU bound operation, use Task.Run to offload the work to a thread from the Thread Pool. Just don't forget that you have to marshal the result back to your main thread manually.

### AV1830    Beware of mixing up await/async with Task.Wait

await will not block the current thread but simply instruct to compiler to generate a state-machine. However, Task.Wait will block the thread and may even cause dead-locks (see AV1835).

### AV1835    Beware of async/await deadlocks in single-threaded environments

Consider the following asynchronous method:

private async Task GetDataAsync()

{

var result = await MyWebService.GetDataAsync();

return result.ToString();

}

Now when an ASP.NET MVC controller action does this:

public ActionResult ActionAsync()

{

var data = GetDataAsync().Result;



return View(data);  
}

You'll end up with a deadlock. Why? Because the Result property getter will block until the async operation has completed, but since an async method will automatically marshal the result back to the original thread and ASP.NET uses a single-threaded synchronization context, they'll be waiting on each other. A similar problem can also happen on WPF, Silverlight or a Windows Store C#/XAML app. Read more about this [here](http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115163.aspx).

1. 8Framework Guidelines

### Use C# type aliases instead of the types from the System namespace  (AV2201) ![](images/?.png)

For instance, use object instead of Object, string instead of String, and int instead of Int32. These aliases have been introduced to make the primitive types a first class citizen of the C# language so use them accordingly,

**Exception** When referring to static members of those types, it is custom to use the full CLS name, e.g. Int32.Parse() instead of int.Parse().

### Properly name properties, variables or fields referring to localized resources  (AV2205) ![](images/?.png)

The guidelines in this topic apply to localizable resources such as error messages and menu text.

- Use Pascal casing in resource keys.
- Provide descriptive rather than short identifiers. Keep them concise where possible, but don't sacrifice readability.
- Use only alphanumeric characters in naming resources.

### Don't hardcode strings that change based on the deployment  (AV2207) ![](images/?.png)

Examples include connection strings, server addresses, etc. Use Resources, the ConnectionStrings property of the ConfigurationManager class, or the Settings class generated by Visual Studio. Maintain the actual values into the app.config or web.config (and most definitely not in a custom configuration store).

### Build with the highest warning level  (AV2210) ![](images/?.png)

Configure the development environment to use **Warning Level 4** for the C# compiler, and enable the option **Treat warnings as errors** . This allows the compiler to enforce the highest possible code quality.

### Properly fill the attributes of the AssemblyInfo.cs file  (AV2215) ![](images/?.png)

Ensure that the attributes for the company name, description, copyright statement, version, etc. are filled. One way to ensure that version and other fields that are common to all assemblies have the same values, is to move the corresponding attributes out of the AssemblyInfo.cs into a SolutionInfo.cs file that is shared by all projects within the solution. 

### Avoid LINQ for simple expressions  (AV2220) ![](images/?.png)

Rather than

var query = from item in items where item.Length > 0;

prefer using the extension methods from the System.Linq namespace.

var query = items.Where(i => i.Length > 0);

Since LINQ queries should be written out over multiple lines for readability, the second example is a bit more readable.

### Use Lambda expressions instead of delegates  (AV2221) ![](images/?.png)

Lambda expressions provide a much more elegant alternative for anonymous delegates. So instead of

Customer c = Array.Find(customers, delegate(Customer c)

{

return c.Name == "Tom";

});

use a Lambda expression:

Customer c = Array.Find(customers, c => c.Name == "Tom");

Or even better

var customer = customers.Where(c => c.Name == "Tom");

### Only use the dynamic keyword when talking to a dynamic object  (AV2230) ![](images/?.png)

The dynamic keyword has been introduced for working with dynamic languages. Using it introduces a serious performance bottleneck because the compiler has to generate some complex Reflection code.

Use it only for calling methods or members of a dynamically created instance (using the Activator) class as an alternative to Type.GetProperty() and Type.GetMethod(), or for working with COM Interop types.

### AV2235    Favor async/await over the Task

Using the new C# 5.0 keywords results in code that can still be read sequentially and also improves maintainability a lot, even if you need to chain multiple asynchronous operations. For example, rather than defining your method like this:

public Task GetDataAsync()

{

  return MyWebService.FetchDataAsync()

    .ContinueWith(t => new Data (t.Result));

}

define it like this:

public async Task GetDataAsync()

{

  var result = await MyWebService.FetchDataAsync();

  return new Data (result);

}

1. 9Documentation Guidelines

### Write comments and documentation in US English  (AV2301) ![](images/?.png)

### Document all public, protected and internal types and members  (AV2305) ![](images/?.png)

Documenting your code allows Visual Studio to pop-up the documentation when your class is used somewhere else. Furthermore, by properly documenting your classes, tools can generate professionally looking class documentation.

### Write XML documentation with another developer in mind  (AV2306) ![](images/?.png)

Write the documentation of your type with another developer in mind. Assume he or she will not have access to the source code and try to explain how to get the most out of the functionality of your type.

### Write MSDN-style documentation  (AV2307) ![](images/?.png)

Following the MSDN on-line help style and word choice helps the developer to find its way through your documentation more easily.

**Tip** The tool [GhostDoc](http://submain.com/products/ghostdoc.aspx)can generate a starting point for documenting code with a shortcut key.

### Avoid inline comments  (AV2310) ![](images/?.png)

If you feel the need to explain a block of code using a comment, consider replacing that block with a method having a clear name.

### Only write comments to explain complex algorithms or decisions  (AV2316) ![](images/?.png)

Try to focus comments on the _why_ and _what_ of a code block and not the _how_. Avoid explaining the statements in words, but instead help the reader understand why you chose a certain solution or algorithm and what you are trying to achieve. If applicable, also mention that you chose an alternative solution because you ran into a problem with the obvious solution.

### Don't use comments for tracking work to be done later  (AV2318) ![](images/?.png)

Annotating a block of code or some work to be done using a TODO or similar comment may seem a reasonable way of tracking work-to-be-done. But in reality, nobody really searches for comments like that. Use a work item tracking system such as Team Foundation Server to keep track of left overs.

1. 10Layout Guidelines

### Use a common layout  (AV2400) ![](images/?.png)

- Keep the length of each line under 130 characters.
- Use an indentation of 4 whitespaces, and don't use tabs
- Keep one whitespace between keywords like if and the expression, but don't add whitespaces after ( and before ) such as: if (condition == null).
- Add a whitespace around operators, like +, -, ==, etc.
- Always succeed the keywords if, else, do, while, for and foreach, with opening and closing parentheses, even though the language does not require it. 
- Always put opening and closing parentheses on a new line.
- Don't indent object Initializers and initialize each property on a new line, so use a format like this: var dto = new ConsumerDto(){  Id = 123,  Name = "Microsoft",  PartnerShip = PartnerShip.Gold,}
- Don't indent lambda statements and use a format like this:methodThatTakesAnAction.Do(x =>{ // do something like this }
- Put the entire LINQ statement on one line, or start each keyword at the same indentation, like this:var query = from product in products where product.Price > 10 select product;orvar query =  from product in products  where product.Price > 10  select product;
- Start the LINQ statement with all the from expressions and don't interweave them with where restrictions.
- Add braces around every comparison condition, but don't add braces around a singular condition. For exampleif (!string.IsNullOrEmpty(str) && (str != "new"))
- Add an empty line between multi-line statements, between members, after the closing parentheses, between unrelated code blocks, around the #region keyword, and between the using statements of different companies.

### Order and group namespaces according the company  (AV2402) ![](images/?.png)

// Microsoft namespaces are first

using System;

using System.Collections;

using System.XML;

// Then any other namespaces in alphabetic order

using AvivaSolutions.Business;

using AvivaSolutions.Standard;

using Telerik.WebControls;

using Telerik.Ajax;

### Place members in a well-defined order  (AV2406) ![](images/?.png)

Maintaining a common order allows other team members to find their way in your code more easily. In general, a source file should be readable from top to bottom, as if you are reading a book. This prevents readers from having to browse up and down through the code file.

1. Private fields and constants (in a region)
2. Public constants
3. Public read-only static fields
4. Factory Methods
5. Constructors and the Finalizer
6. Events 
7. Public Properties
8. Other methods and private properties in calling order

### Be reluctant with #regions  (AV2407) ![](images/?.png)

Regions can be helpful, but can also hide the main purpose of a class. Therefore, use #regions only for:

- Private fields and constants (preferably in a Private Definitions region).
- Nested classes
- Interface implementations (only if the interface is not the main purpose of that class)

1. 11Important Resources
  1. 1 [The](http://www.csharpcodingguidelines.com) companion website

This document is part of an effort to increase the consciousness with which C# developers do their daily job on a professional level. Therefor I've started a dedicated CodePlex site that can be easily found using the URL [www.csharpcodingguidelines.com](http://www.csharpcodingguidelines.com).

In addition to the most up to date version of this document, you'll find:

- A companion quick-reference sheet
- Visual Studio 2010/2012 Rule Sets for different types of systems.

[ReSharper](http://www.jetbrains.com/resharper/download/) layout configurations matching the rules in chapter 10.

- A place to have discussions on C# coding quality.

1. 
  1. 2Useful links

In addition to the many links provided throughout this document, I'd like to recommend the following books, articles and sites for everyone interests in software quality,

[Code Complete: A Practical Handbook of Software Construction](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670) (Steve McConnel)  
One of the best books I've ever read. It deals with all aspects of software development, and even though the book was originally written in 2004, but you'll be surprised when you see how accurate it still is. I wrote a [review](http://www.dennisdoomen.net/2009/07/book-review-code-complete-2nd-edition.htmlhttp:/www.dennisdoomen.net/2009/07/book-review-code-complete-2nd-edition.html) in 2009 if you want to get a sense of its contents.

[The Art of Agile Development](http://www.amazon.com/Art-Agile-Development-James-Shore/dp/0596527675) (James Shore)  
Another great all-encompassing trip through the many practices preached by processes like Scrum and Extreme Programming. If you're looking for a quick introduction with a pragmatic touch, make sure you read James' book.

[Applying Domain Driven-Design and Patterns: With Examples in C# and .NET](http://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202) (Jimmy Nilsson)  
The book that started my interest for both Domain Driven Design and Test Driven Development. It's one of those books that I wished I had read a few years earlier. It would have saved me from many mistakes..

[Jeremy D. Miller's Blog](http://codebetter.com/blogs/jeremy.miller/)  
Although he is not that active anymore, in the last couple of years he has written some excellent blog posts on Test Driven Development, Design Patterns and design principles. I've learned a lot from his real-life and practical insights.

[LINQ Framework Design Guidelines](http://blogs.msdn.com/b/mirceat/archive/2008/03/13/linq-framework-design-guidelines.aspx)  
A set of rules and recommendations that you should adhere to when creating your own implementations of IQueryable.

[Best Practices for c# async/await](http://code.jonwagner.com/2012/09/06/best-practices-for-c-asyncawait/)  
The rationale and source of several of the new guidelines in this documented, written by [Jon Wagner](https://twitter.com/jonwagnerdotcom).
